# 개발 고려사항 및 설계 결정

## 설계 고민사항

### 1. 아키텍처 선택: 모놀리식 vs 마이크로서비스

**고려사항들:**
- **모놀리식 아키텍처**:
  - 장점: 단순한 배포, 트랜잭션 관리 용이, 낮은 네트워크 오버헤드
  - 단점: 확장성 제한, 기술 스택 제약, 장애 전파 위험

- **마이크로서비스 아키텍처**:
  - 장점: 독립적 확장, 기술 다양성, 장애 격리
  - 단점: 분산 시스템 복잡성, 네트워크 오버헤드, 데이터 일관성 문제

**최종 결정: 마이크로서비스**
- 이유: 각 도메인(회원, 상품, 주문, 결제)이 명확히 분리되고, 독립적인 확장이 필요한 전자상거래 특성
- 캐시노트 마켓의 성장 가능성을 고려한 확장성 우선 고려

### 2. 내부 통신 방식: REST vs gRPC vs Message Queue

**고려사항들:**
- **REST API**: 단순함, 디버깅 용이성
- **gRPC**: 성능, 타입 안정성, 바이너리 프로토콜
- **Message Queue**: 비동기 처리, 장애 복구

**최종 결정: gRPC + Kafka 조합**
- gRPC: 동기적 서비스 간 호출 (회원 조회, 상품 조회 등)
- Kafka: 비동기 이벤트 처리 (주문 생성 알림, 결제 완료 등)
- 이유: 성능과 확장성을 동시에 확보

### 3. 결제 시스템 설계: 단순 분기 vs Strategy Pattern

**고려사항들:**
- **단순 분기 (if-else)**:
  - 장점: 구현 단순함
  - 단점: 새로운 결제수단 추가 시 기존 코드 수정 필요

- **Strategy Pattern**:
  - 장점: 확장성, 테스트 용이성, 결제수단별 독립적 구현
  - 단점: 초기 구현 복잡도 증가

**최종 결정: Strategy Pattern**
- 이유: 캐시노트 마켓의 다양한 결제수단 요구사항 (PG, 캐시포인트, 쿠폰, BNPL)
- 향후 새로운 결제수단 추가 시 기존 코드 수정 없이 확장 가능

## 트레이드오프 분석

### 1. 데이터 일관성 vs 성능

**선택**: 최종적 일관성(Eventual Consistency) 채택
- **이유**: 
  - 전자상거래에서 완벽한 강일관성보다는 가용성이 더 중요
  - 보상 트랜잭션으로 데이터 정합성 보장
- **타협점**:
  - 중요한 비즈니스 로직(재고 차감, 캐시포인트 차감)은 동시성 제어 적용
  - 이벤트 기반으로 비동기 데이터 동기화

### 2. 개발 속도 vs 품질

**선택**: 품질 우선, 단계적 구현
- **이유**: 금융 관련 로직(결제)의 안정성이 최우선
- **접근법**:
  - Mock 서비스로 빠른 개발 환경 구성
  - 테스트 주도 개발 적용
  - 문서화 병행

### 3. 복잡성 vs 확장성

**선택**: 복잡성을 감수하고 확장성 확보
- **이유**: 스타트업에서 대기업까지 성장 가능성 고려
- **완화 방안**:
  - 철저한 문서화
  - 표준화된 패턴 적용
  - 단계적 학습 곡선 제공

## 개선 방향

### 단기 개선사항 (1-3개월)

1. **보안 강화**
   - JWT 기반 인증/인가 구현
   - API Gateway 도입
   - 민감 데이터 암호화

2. **모니터링 강화**
   - Prometheus + Grafana 도입
   - 분산 추적 (Jaeger/Zipkin)
   - 장애 알림 시스템

3. **테스트 커버리지 향상**
   - 단위 테스트 80% 이상
   - 통합 테스트 자동화
   - 성능 테스트 구축

### 중기 개선사항 (3-6개월)

1. **성능 최적화**
   - 캐시 레이어 도입 (Redis)
   - 데이터베이스 튜닝
   - 쿼리 최적화

2. **확장성 개선**
   - 로드 밸런서 구성
   - 오토 스케일링
   - 데이터베이스 샤딩

3. **운영 자동화**
   - CI/CD 파이프라인 구축
   - 무중단 배포
   - 자동 백업/복구

### 장기 개선사항 (6개월 이상)

1. **고가용성 구성**
   - 멀티 리전 배포
   - 장애 복구 자동화
   - 재해 복구 계획

2. **비즈니스 확장**
   - 국제화 지원
   - 새로운 결제수단 확장
   - B2B 기능 추가

## 제약사항 및 한계

### 현재 구현의 제약사항

1. **기술적 제약**
   - 단일 데이터베이스 사용 (분산 데이터베이스 미적용)
   - Mock 외부 서비스 (실제 PG, BNPL 연동 필요)
   - 기본적인 보안 수준

2. **비즈니스 제약**
   - 간소화된 쿠폰 시스템
   - 기본적인 재고 관리
   - 단순한 주문 상태 관리

3. **운영 제약**
   - 개발 환경 수준의 설정
   - 기본적인 모니터링
   - 수동 배포 과정

### 트래픽 확장 시 병목점

**10배 트래픽 증가 시**:
- **예상 병목**: 데이터베이스 연결 수, 단일 Kafka 브로커
- **해결방안**: 연결 풀 튜닝, Kafka 클러스터링, 서비스 인스턴스 증설

**100배 트래픽 증가 시**:
- **예상 병목**: 데이터베이스 I/O, 네트워크 대역폭, 메모리 사용량
- **해결방안**: 
  - 데이터베이스 샤딩 및 읽기 전용 복제
  - CDN 도입
  - 캐시 레이어 강화
  - 마이크로서비스별 오토 스케일링

## 코드 품질 및 유지보수성

### 적용된 설계 원칙

1. **SOLID 원칙**
   - SRP: 각 클래스는 단일 책임
   - OCP: Strategy Pattern으로 확장에 열려있고 수정에 닫혀있음
   - LSP: 인터페이스 기반 구현
   - ISP: 세분화된 인터페이스 분리
   - DIP: 의존성 역전으로 추상화에 의존

2. **Clean Architecture**
   - 도메인 중심 설계
   - 의존성 방향 제어
   - 계층별 명확한 역할 분리

3. **DDD (Domain-Driven Design)**
   - 도메인별 서비스 분리
   - 도메인 모델의 비즈니스 로직 캡슐화
   - 이벤트 기반 도메인 간 통신

### 코드 일관성

- **명명 규칙**: Kotlin 코딩 컨벤션 준수
- **패키지 구조**: 헥사고날 아키텍처 기반 일관된 구조
- **에러 처리**: 일관된 예외 처리 및 응답 형식
- **로깅**: 구조화된 로깅 패턴

이러한 설계 결정들은 초기 개발 복잡도를 높였지만, 장기적인 유지보수성과 확장성을 위한 투자라고 판단했습니다.
